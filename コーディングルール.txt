以下のドキュメントと書籍の内容に準拠した上で、dead-library 独自のルールを設けています。
完全に対応するのは難しいですが、ルールに合わない記載を見つけた場合は修正対象となります。
ルールについてはこれでフィックスではないため、今後、加筆・修正する可能性があります。

	1. アンリアルエンジンのコーディング規約。
	2. 書籍『リーダブルコード』の内容。

///////////////////////////////////////////////////////////////////////////////

コーディングスタイル

基本的に Visual Studio の設定に従う。
editor.config で完全に対応できていないため、以下に記載する内容は例外とする。

.Net Standard 2.0 / C# 7 基準で記載する。
それ以外のバージョンは、Unity のマルチプラットフォーム用 dll が対応していないため。

https://docs.unity3d.com/ja/2021.3/Manual/dotnetProfileSupport.html

///////////////////////////////////////////////////////////////////////////////

テキストフォーマット

エンコードは UTF-8 (BOM / シグネチャあり)。
改行コードは CRLF (Windows 準拠)。

///////////////////////////////////////////////////////////////////////////////

レイアウト

80 桁(列)を目途に改行を入れる。
100 桁へ達する前に必ず改行を入れる。
改行するためにコードを無理やり省略して書かない。

///////////////////////////////////////////////////////////////////////////////

インデント

インデントはタブ(スペース４つ分)を使う。
行頭のインデント以外の桁揃えはスペースを使う。

↓行頭のインデントはタブ
	     ↓行中の桁揃えはスペース
	             ↓行中の桁揃えはスペース
	int a   = 0;     // コメント
	int ab  = 12345; // コメント
	int abc = -123;  // コメント

インデントがおかしくなるときがままあるので、それは直す。
インデントがスペースに変換されるときがあるので、タブに直す。

///////////////////////////////////////////////////////////////////////////////

using

.Net 7 以降の global using は使用しない。

必要なものを必ず行頭で宣言する。
不要なものは push する前に削除する。

エイリアスを定義するための using と、using ブロックとして使用することは問題ありません。
ただし、C# 7 で使用可能な場合に限ります。

// エイリアス
using Hoge = System.Console;

// using ブロック
class Hoge : IDisposable {
	public void Dispose() {}
}
using (var hoge = new Hoge()) {
	// ブロックを出る際に hoge の Dispose が呼ばれる。
}

///////////////////////////////////////////////////////////////////////////////

名前について

・コンパイル制御マクロは全て大文字のスネークケース。
・const または readonly は大文字開始のスネークケース。
・引数と一時変数は全て小文字のスネークケース。
・プロパティ、メソッドはパスカルケース。
・フィールドは小文字開始のキャメルケース(Lowerキャメルケース）。

bool型の名前
can + 動詞
must + 動詞(should/haveto/hastoは曖昧なので非推奨)
has + 動詞
is + 過去分詞
is + 名詞

is + 動詞は間違った文法なのでis + 動詞を使うなら動詞は過去分詞型にする。

///////////////////////////////////////////////////////////////////////////////

波カッコは省略しない。
アンリアルエンジンのコーディングルールにも記載されているが、
見落としやすいので再度記載。

if (0) { return; }	//OK
if (0) return;		//NG

///////////////////////////////////////////////////////////////////////////////

波カッコの前に改行を入れない

//NG
if (0)
{
}

//OK
if (0) {
}

波カッコの前に何もない（ブロック用）は { の上に空行を１つ入れる。

<空行>
{
	int a = 0;
}

例
if (0) {
}
else if (0) {
}
else {
}

///////////////////////////////////////////////////////////////////////////////

一行に１ステートメント

//OK
int i = 0;
return i;

//NG
int i = 0; return i;

詰めて書かない

//NG
int i = 0;
i += 2;
Console.WriteLine(i);
int j = i;

//OK
int i = 0;
i += 2;
Console.WriteLine(i);

int j = i;

ひとつの処理が終わったら空行を入れて、別の処理に変わることをコードで明示する

///////////////////////////////////////////////////////////////////////////////

参照元の明確化

参照しているのが自分なのか親なのか、別のクラスなのかを明確にする
参照元が何なのかが明確でないと、それを調べるのに若干時間がかかる

非 static なフィールド/プロパティ/メソッド実行を行うときは this. をつける

this.nonStaticField = 0; //OK
nonStaticField = 0;      //NG

クラスの static なものにアクセスする場合はそのクラス名をつける

CallStaticMethod();                 //NG
SomeClass.CallStaticMethod();       //OK
GenericClass<T>.CallStaticMethod(); //OK

親クラスのフィールド/プロパティ/メソッドを使うときは this. ではなく base. を使う

interface クラスの親を持ち、親のメソッドやプロパティを実装する際、
親のクラス名を付けるかどうかは以下のどちらかを行う。
※virtual メソッドやプロパティの場合は override キーワードを付ける必要があるので自明。

1. 親クラス名を付ける場合はコメントで明記する必要はない。
2. 親クラス名を付けない場合はコメントで明記する。

interface IHoge {
	void Test();
}
class Derived : IHoge {
	public void Test() {}       // IHoge.Test メソッドの実装
	public void IHoge.Test() {} // この場合コメントは不要
}

///////////////////////////////////////////////////////////////////////////////

代理変数を積極的に使う

条件式がややこしい時は代理変数で明確にする

const bool can_add_player = condition1 == 5 && (!condition2 || condition3 > 0);
if (can_add_player) { this.AddPlayer(); }

式を見なくても、変数名で理解できるよう積極的に使う
デバッグでステップ実行する際に、代理変数の値を参照することで式の結果が分かるようにする
問題を局所化し、修正しやすいコードにするため

///////////////////////////////////////////////////////////////////////////////

const と readonly

const や readonly が使えるなら必ず使う 
どちらも使えるなら readonly を使う

const int Constant_Value = 999;

変更してはいけない値なのに、const も readonly も付けられない場合は、
dead-library の Constraint クラスを使う。

///////////////////////////////////////////////////////////////////////////////

private / internal はつけない
C++ と違って struct と class で省略時のアクセス制限が変わらないので
入力する手間を省く
ついていないものは private / internal であることが自明

///////////////////////////////////////////////////////////////////////////////

== true と == false

true / false は条件式で明示しない
いちいち書かなくても意味は通じる

if (is_hoge == true) //NG
if (is_hoge)         //OK

条件式が複雑なとき（true のときにどんな意味になるのか瞬時に判断できない場合）は
代理変数を使って条件式の意味を変数名によって明確にする

///////////////////////////////////////////////////////////////////////////////

条件式の判定方法

条件式は常に true で判断する
false で判断したい場合は代理変数を使う

bool is_not_read_only = ...;
if (is_not_read_only) { }

bool is_read_only = ...;
if (is_read_only) { }

bool has_special_item = ...;
bool is_not_common_item = ...;
bool is_rarelity_greater_than_4 = ...;
if (has_special_item && is_not_common_item && is_rarelity_grater_than_4) { }

///////////////////////////////////////////////////////////////////////////////

算術記号のマージン

インクリメント、または、デクリメント、または、負数を表すときを除き、
原則として算術記号の前後にスペースを１つ以上入れる。
改行とタブもスペースとみなす。

int a = 1 + b;
int b = -8;
int c = a / (c * -99);
int d = 1 >> 2;

b = a++;
c = b++ * --a;

///////////////////////////////////////////////////////////////////////////////

プライオリティ

計算の順番が明らかなときは()で括らない。
プライオリティーは言語仕様で明確になっているので、付けなくて良いときに
()をつけると第三者が見たときに意図が分からない。

C++ のように、言語仕様で明確なのにコンパイラの独自仕様で付けなければならないような
特殊なケースは C# にはないと思われる。

・書いた人が演算子の優先順位を覚えていないからなのか？
・メモリ破壊などによって引き起こされた、その箇所でのみ発生するバグを回避するためなのか？
・特定の環境でプライオリティが変わるからなのか？
・特定の環境でビルドが通らないからなのか？
…などの可能性を考慮しなくて済むようにするため

int c = a / c * -99;	//OK	a/c が先に計算される意図ならこのままで良い
int c = (a / c) * -99;	//NG

int c = a / (c * -99);	//OK	c * -99 を先に計算する意図ならこれでOK
