以下のドキュメントと書籍の内容に準拠した上で、Dead Library 独自のルールを設けています。
完全に対応するのは難しいですが、ルールに合わない記載を見つけた場合は修正対象となります。
ルールについてはこれでフィックスではないため、今後、加筆・修正する可能性があります。

	1. アンリアルエンジンのコーディング規約。
	2. 書籍『リーダブルコード』の内容。

///////////////////////////////////////////////////////////////////////////////

コーディングスタイル

基本的に Visual Studio の設定に従う。
editor.config で完全に対応できていないため、以下に記載する内容は例外とする。

.Net Standard 2.0 / C# 7 基準で記載する。
それ以外のバージョンは、Unity のマルチプラットフォーム用 dll が対応していないため。

https://docs.unity3d.com/ja/2021.3/Manual/dotnetProfileSupport.html

///////////////////////////////////////////////////////////////////////////////

テキストフォーマット

エンコードは UTF-8 (BOM / シグネチャあり)。
改行コードは CRLF (Windows 準拠)。

///////////////////////////////////////////////////////////////////////////////

レイアウト

80 桁(列)を目途に改行を入れる。
100 桁へ達する前に必ず改行を入れる。
改行するためにコードを無理やり省略して書かない。

///////////////////////////////////////////////////////////////////////////////

インデント

インデントはタブ(スペース４つ分)を使う。
行頭のインデント以外の桁揃えはスペースを使う。

↓行頭のインデントはタブ
	     ↓行中の桁揃えはスペース
	             ↓行中の桁揃えはスペース
	int a   = 0;     // コメント
	int ab  = 12345; // コメント
	int abc = -123;  // コメント

インデントがおかしくなるときがままあるので、それは直す。
インデントがスペースに変換されるときがあるので、タブに直す。

///////////////////////////////////////////////////////////////////////////////

using

.Net 7 の global using は使用しない。
必要なものを必ず行頭で宣言する。
不要なものは push する前に削除する。

///////////////////////////////////////////////////////////////////////////////

名前について

・コンパイル制御マクロは全て大文字のスネークケース。
・const または readonly は大文字開始のスネークケース。
・引数と一時変数は全て小文字のスネークケース。
・プロパティ、メソッドはパスカルケース。
・フィールドは小文字開始のキャメルケース(Lowerキャメルケース）。

bool型の名前
can + 動詞
must + 動詞(should/haveto/hastoは曖昧なので非推奨)
has + 動詞
is + 過去分詞
is + 名詞

is + 動詞は間違った文法なのでis + 動詞を使うなら動詞は過去分詞型にする。

///////////////////////////////////////////////////////////////////////////////

波カッコは省略しない。
アンリアルエンジンのコーディングルールにも記載されているが、
見落としやすいので再度記載。

if (0) { return; }	//OK
if (0) return;		//NG

///////////////////////////////////////////////////////////////////////////////

波カッコの前に改行を入れない

//NG
if (0)
{
}

//OK
if (0) {
}

波カッコの前に何もない（ブロック用）は { の上に空行を１つ入れる。

<空行>
{
	int a = 0;
}

例
if (0) {
}
else if (0) {
}
else {
}

///////////////////////////////////////////////////////////////////////////////

一行に１ステートメント

//OK
int i = 0;
return i;

//NG
int i = 0; return i;

詰めて書かない

//NG
int i = 0;
i += 2;
Console.WriteLine(i);
int j = i;

//OK
int i = 0;
i += 2;
Console.WriteLine(i);

int j = i;

ひとつの処理が終わったら空行を入れて、別の処理に変わることをコードで明示する

///////////////////////////////////////////////////////////////////////////////

参照しているのが自分なのか親なのか、別のクラスなのかを明確にするため
参照元が何なのかが明確でないと、それを調べるのに若干時間がかかる

非 static なフィールド/プロパティ/メソッド実行を行うときは this. をつける

this.nonStaticField = 0; //OK
nonStaticField = 0;      //NG

クラスの static なものにアクセスする場合はそのクラス名をつける

CallStaticMethod();                 //NG
SomeClass.CallStaticMethod();       //OK
GenericClass<T>.CallStaticMethod(); //OK

親クラスのフィールド/プロパティ/メソッドを使うときは this. ではなく base. を使う

///////////////////////////////////////////////////////////////////////////////

条件式がややこしい時は代理変数で明確にする

const bool can_add_player = condition1 == 5 && (!condition2 || condition3 > 0);
if (can_add_player) { this.AddPlayer(); }

///////////////////////////////////////////////////////////////////////////////

const や readonly が使えるなら必ず使う 
どちらも使えるなら readonly を使う

const int Constant_Value = 999;

変更してはいけない値なのに、const も readonly も付けられない場合は、
Dead Library の Constraint クラスを使う。

///////////////////////////////////////////////////////////////////////////////

private / internal はつけない
C++ と違って struct と class で省略時のアクセス制限が変わらないので
入力する手間を省く
ついていないものは private / internal であることが自明

///////////////////////////////////////////////////////////////////////////////

true / false は条件式で明示しない
いちいち書かなくても意味は通じる

if (is_hoge == true) //NG
if (is_hoge)         //OK

条件式が複雑なとき（true のときにどんな意味になるのか瞬時に判断できない場合）は
代理変数を使って条件式の意味を明確にする

///////////////////////////////////////////////////////////////////////////////

条件式は常に true で判断する
false で判断したい場合は代理変数を使う

bool is_not_read_only = ...;
if (is_not_read_only) { }

bool is_read_only = ...;
if (is_read_only) { }

bool has_special_item = ...;
bool is_not_common_item = ...;
bool is_rarelity_greater_than_4 = ...;
if (has_special_item && is_not_common_item && is_rarelity_grater_than_4) { }

///////////////////////////////////////////////////////////////////////////////

インクリメント、または、デクリメント、または、負数を表すときを除き、
原則として算術記号の前後にスペースを１つ以上入れる。
改行とタブもスペースとみなす。

int a = 1 + b;
int b = -8;
int c = a / (c * -99);
int d = 1 >> 2;

b = a++;
c = b++ * --a;

///////////////////////////////////////////////////////////////////////////////

計算の順番が明らかなときは()で括らない。
プライオリティーは言語仕様で明確になっているので、付けなくて良いときに
()をつけると第三者が見たときに意図が分からない。

C++ のように、言語仕様で明確なのにコンパイラの独自仕様で付けなければならないような
特殊なケースは C# にはないと思われる。

書いた人が演算子の優先順位を覚えていないからなのか？
それとも、メモリ破壊などによって引き起こされた、その箇所でのみ発生する
不可解なバグを回避するためなのか？

int c = a / c * -99;	//OK	a/c が先に計算される意図ならこのままで良い
int c = (a / c) * -99;	//NG

int c = a / (c * -99);	//OK	c * -99 を先に計算する意図ならこれでOK
